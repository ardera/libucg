-- libucg, library for encoding & decoding of UCG formatted data
local version = "1.3.0"

local doFastIO = false
do
	local s = string.dump(function() end)
	if s:sub(1, 3) == string.char(27).."L".."J" then
		doFastIO = true
		-- check if in CCLite environment
		-- CCLite is the only CC emulator whose io implementation handles strings with full 8-bit characters correctly
		-- (Bug in LuaJ)
	end
end

function getVersion()
	return version
end

-------------------------------------
---------- UCG FILE FORMAT ----------
-------------------------------------
local formatVersion = 2
function getFormatVersion()
	return formatVersion
end

local function newBuffer(mode, source)
	local bytes = {}
	local srcstr
	local bits = {}
	
	if type(source) == "table" then
		bytes = source
	elseif type(source) == "string" then
		srcstr = source
	end
	
	local bitcache = 0
	local pointer = 1
	local bitcounter = 0
	local bytestr = ""
	
	local buf = {}
	if mode == "w" then
		local function writeByteRaw(b)
			bytes[pointer] = b
			bytestr = bytestr..string.char(b)
			pointer = pointer +1
		end
		
		local function flushBitcacheReal()
			local rest = bitcounter % 8
			local low, x
			for a = bitcounter, 8, -8 do
				low = 2^(a-8)
				bitcache = bitcache % 2^a
				x = (bitcache - (bitcache % low)) / low
				writeByteRaw(x)
			end
			bitcache = bitcache % 2^rest
			bitcounter = rest
		end
	
		local function flushBitcache()
			if bitcounter >= 8 then
				flushBitcacheReal()
			end
		end
		
		local function writeBit(b)
			bitcache = bitcache *2
			if b == 1 or b == true then
				bitcache = bitcache +1 
			end
			bitcounter = bitcounter +1
			
			if bitcounter >= 8 then
				flushBitcacheReal()
			end
		end
		buf.writeBit = writeBit
		
		local function writeByte(b)
			if bitcounter == 0 then
				writeByteRaw(b)
				return
			end
			
			bitcache = (bitcache * 256) + b
			bitcounter = bitcounter + 8
			
			if bitcounter >= 8 then
				flushBitcacheReal()
			end
		end
		buf.writeByte = writeByte
		
		local function writeNumber(nbits, n)
			if nbits == 1 then
				writeBit(n)
				return
			end
			
			bitcache = (bitcache * 2^nbits) + n
			bitcounter = bitcounter + nbits
			
			if bitcounter >= 8 then
				flushBitcacheReal()
			end
		end
		buf.writeNumber = writeNumber
		
		function buf.writeBytes(bs)
			for a = 1, #bs do
				writeByte(bs[a])
			end
		end
		function buf.writeBits(bits)
			for a = 1, #bits do
				writeBit(bits[a])
			end
		end
		
		function buf.writeWord(b)
			if bitcounter == 0 then
				writeByteRaw((b-(b%256))/256)
				writeByteRaw(b%256)
				return
			end
			
			bitcache = (bitcache * 2^16) + b
			bitcounter = bitcounter + 16
			
			flushBitcacheReal()
		end
		function buf.writeInteger(b)
			if bitcounter == 0 then
				local h1, h2, h3 = 2^24, 2^16, 2^8
				writeByteRaw((b-(b%h1))/h1)
				writeByteRaw(((b%h1)-(b%h2))/h2)
				writeByteRaw(((b%h2)-(b%h3))/h3)
				writeByteRaw(b%h3)
				return
			end
			
			bitcache = (bitcache * 2^32) + b
			bitcounter = bitcounter + 32
			
			flushBitcacheReal()
		end
		
		function buf.finishByte(b)
			local rest = 8 - (bitcounter % 8)
			if rest == 8 then
				rest = 0
			end
			bitcache = bitcache * 2^rest
			bitcounter = bitcounter + rest
			flushBitcacheReal()
		end
		
		function buf.getBytes()
			return bytes
		end
		function buf.getString()
			return bytestr
		end
		
		function buf.getSize()
			return #bytes
		end

		function buf.newVariableCodeInterface()
			local f = {}
			local valueToHuff = {}
			function f.loadCodes(t)
				local v = 0
				for a, b in pairs(t) do
					v = 0
					for c = 1, #b do
						if b[c] == 1 then
							v = v + (2^(#b-c))
						end
					end
					valueToHuff[a] = {l = #b, v = v}
				end
				return f
			end
			
			function f.writeValue(v)
				local x = valueToHuff[v]
				writeNumber(x.l, x.v)
				return f
			end
			
			return f
		end
	elseif mode == "r" then
		local function readByteRaw()
			local b
			if srcstr then
				b = srcstr:sub(pointer, pointer):byte()
			else
				b = bytes[pointer]
			end
			pointer = pointer +1
			
			return b
		end
		local function updateCache()
			bitcache = bitcache*256 + readByteRaw()
			bitcounter = bitcounter +8
		end
		
		local function readNumber(nbits)
			while bitcounter < nbits do
				updateCache()
			end
			if bitcounter == nbits then
				bitcounter = 0
				local v = bitcache
				bitcache = 0
				return v
			else
				local v = (bitcache - bitcache % 2^(bitcounter-nbits)) / 2^(bitcounter-nbits)
				bitcache = bitcache % 2^(bitcounter-nbits)
				bitcounter = bitcounter-nbits
				return v
			end
		end
		buf.readNumber = readNumber
		
		local function readBit()
			if bitcounter == 0 then
				updateCache()
			end
			local v = (bitcache - bitcache % 2^(bitcounter-1)) / 2^(bitcounter-1)
			bitcounter = bitcounter -1
			bitcache = bitcache % 2^bitcounter
			return v
		end
		buf.readBit = readBit
		
		local function readBits(nbits)
			local t = {}
			for a = 1, nbits do
				t[a] = readBit()
			end
			return t
		end
		buf.readBits = readBits
		
		local function readByte()
			return readNumber(8)
		end
		buf.readByte = readByte
		
		function buf.readWord()
			return readNumber(16)
		end
		function buf.readInteger()
			return readNumber(32)
		end
		
	else
		error("invalid buffer mode: "..tostring(mode), 2)
	end
	
	function buf.getPointer()
		return pointer
	end
	function buf.getBitPointer()
		return bitcounter or bitpointer
	end
	function buf.getType()
		return mode
	end
	
	return buf
end

local alphabet, iAlphabet
do
	alphabet = {6, 2, 10, 3, 11, 9, 8, 7, 12, 14, 1, 4, 5, 13, 15}
	alphabet[0] = 0
	iAlphabet = {}
	for n = 0, #alphabet do iAlphabet[alphabet[n]] = n end
end

-- encodes an image and returns a string (w and h are optional)
function encode(tImage, w, h)
	-- first, count colors
	
	if not w then
		w = 0
		for a = 1, #tImage do
			w = math.max(w, #tImage[a])
		end
	end
	if not h then
		h = #tImage
	end
	
	if w > 65535 or h > 65535 then
		return nil, "image too large"
	end
		
	local function counterAdd(t, k)
		if t[k] then
			t[k].p = t[k].p +1
		else
			t[k] = {p = 1, v = {[k] = {}}, tree = k, k = k}
		end
	end
	
	local lengthCounter = {}
	local indexCounter = {}
	local fragments = {}
	
	local sCol, sIndex, sLen = 0, 0, 0
	for y = 1, h do
		
		fragments[y] = {}
		sLen = 0
		for x = 1, w+1 do
			color = tImage[y][x]
			if color and color ~= 0 then
				color = math.log(color)/math.log(2)
			else
				color = 16
			end
			
			if x == 1 then sCol=color sIndex=iAlphabet[color] or 16 end
			if x == w+1 then color = -1 end
			
			if sCol == color then
				sLen = sLen +1
			else
				fragments[y][#fragments[y] +1] = {c = sCol, i = sIndex, l = sLen}
				counterAdd(indexCounter, sIndex)
				counterAdd(lengthCounter, sLen)
				--print(sIndex)
				
				sLen = 1
				if color == -1 then
					sIndex = -1
				elseif color == 16 then
					sIndex = 16
				elseif sCol == 16 then
					sIndex = iAlphabet[color]
					--print("index = ", sIndex)
				else
					sIndex = (iAlphabet[color] - iAlphabet[sCol]) % 16
				end
				sCol = color
			end
		end
	end
	
	local buffer = newBuffer("w")
	local writeByte, writeChar, writeBit, writeBits, writeNumber, finishByte, writeWord, writeInteger = 
		buffer.writeByte, buffer.writeChar, buffer.writeBit, buffer.writeBits, buffer.writeNumber, buffer.finishByte, buffer.writeWord, buffer.writeInteger
	
	local function writeHufftree(tree, writeValue)
		local towrite, towrite2 = {tree}
		while #towrite > 0 do
			towrite2 = {}
			for a = 1, #towrite do
				if type(towrite[a]) == "number" then
					writeBit(1)
					writeValue(towrite[a])
				else
					writeBit(0)
					towrite2[#towrite2 +1] = towrite[a][0]
					towrite2[#towrite2 +1] = towrite[a][1]
				end
			end
			towrite = towrite2
		end
	end
	
	local function generateHuffmanTree(c, writeValue)
		local e1, e2, en;
		
		local numentries = 0
		for _1, _2 in pairs(c) do numentries = numentries +1; en = _2 end
		
		while numentries > 1 do
			e1, e2 = nil, nil
			numentries = 0
			
			for _, e in pairs(c) do
				if (e1 == nil) or (e.p < e1.p) then
					if (e2 == nil) or (e1.p < e2.p) then
						e2 = e1
					end
					e1 = e
				elseif (e2 == nil) or (e.p < e2.p) then
					e2 = e
				end
				numentries = numentries +1
			end
			
			c[e1.k] = nil
			en = {k = e2.k, p = e1.p + e2.p, v = {}, tree = {[0] = e1.tree, [1] = e2.tree}}
			for a, b in pairs(e1.v) do en.v[a] = {0, unpack(b)} end
			for a, b in pairs(e2.v) do en.v[a] = {1, unpack(b)} end
			c[e2.k] = en
			
			numentries = numentries -1
		end
		
		if writeValue then
			writeHufftree(en.tree, writeValue)
			local face = buffer.newVariableCodeInterface()
			face.loadCodes(en.v)
			return face.writeValue
		end
		
		return en.v, en.tree, e1 == nil
	end

	-- Header: 0xFF2137
	-- U is the 21st letter in the alphabet
	-- C is the 3rd letter in the alphabet
	-- G is the 7th letter in the alphabet
	writeByte(0xFF)
	writeByte(0x21)
	writeByte(0x37)
	writeByte(formatVersion)
	
	-- flags currently unused
	flags = {0, 0, 0, 0,    0, 0, 0, 0}
	writeBits(flags)
	writeWord(w)
	writeWord(h)
	
	local iWrite = generateHuffmanTree(indexCounter,
		function(v)
			writeNumber(5, v)
		end)
	
	local lWrite = generateHuffmanTree(lengthCounter,
		function(v)
			if v <= 12 then
				writeNumber(4, v)
			else
				local nbits = math.ceil(math.log(v+1)/math.log(2))
				if nbits <= 5 then
					writeNumber(4, 13)
					writeNumber(5, v)
				elseif nbits <= 8 then
					writeNumber(4, 14)
					writeNumber(8, v)
				else
					writeNumber(4, 15)
					writeNumber(16, v)
				end
			end
		end)
	
	-- write image data
	local line
	for y = 1, h do
		line = fragments[y]
		for x = 1, #line do
			iWrite(line[x].i)
			lWrite(line[x].l)
		end
	end
	
	finishByte(0)
	
	if doFastIO then
		return buffer.getString()
	else
		return buffer.getBytes()
	end
end

-- encodes an image an writes it to a file
function writeFile(path, tImage)
	if type(path) ~= "string" then error("Argument #1: string expected", 2) end
	if type(tImage) ~= "table" then error("Argument #2: table expected", 2) end
	if not fs.isDir(path) and not fs.isReadOnly(path) then
		local b, err = encode(tImage)
		if b then
			if doFastIO then
				local w = fs.open(path, "w")
				w.write(bstring)
				w.close()
			else
				local w = fs.open(path, "wb")
				for _ = 1, #b do
					w.write(b[_])
				end
				w.close()
			end
		else
			error(err)
		end
	else
		error("Can't write to "..path, 2)
	end
	return true
end

-- decodes an array of bytes in UCG format and returns an image
function decode(source)
	local buffer = newBuffer("r", source)
	local readNumber, readWord, readBits, readBit, readByte = buffer.readNumber, buffer.readWord, buffer.readBits, buffer.readBit, buffer.readByte
	
	local sign = 0xFF2137
	if readNumber(24) ~= sign then
		return nil, false, "invalid signature! "..tostring(n)
	end
	
	
	local version = readByte()
	
	local tImage = {}
	if version == 2 then
		
		local flags, w, h = readBits(8), readWord(), readWord()
		
		local function readHuffmanTree(readValue)
			local codes = {}
			local toread = {1}
			local toread2
			local length = 0
			local minLength = 0
			
			if readBit() == 1 then
				return readValue(), true
			end
			
			local bin, c0, c1;
			while #toread > 0 do
				toread2 = {}
				length = length +1
				for a = 1, #toread do
					bin = toread[a]
					c0, c1 = bin*2, bin*2 +1
					
					if readBit() == 1 then
						if minLength == 0 then minLength = length end
						local v = readValue()
						codes[c0] = v
					else
						toread2[#toread2 +1] = c0
					end
					
					if readBit() == 1 then
						if minLength == 0 then minLength = length end
						local v = readValue()
						codes[c1] = v
					else
						toread2[#toread2 +1] = c1
					end
				end
				toread = toread2
			end
			
			return codes, nil, minLength
		end
		
		local indexcodes, monoindex, minIClength = readHuffmanTree(function()
			return readNumber(5)
		end)
		
		local lengthcodes, monolength, minLClength = readHuffmanTree(function()
			local b = readNumber(4)
			if b <= 12 then
				return b
			elseif b == 13 then
				return readNumber(5)
			elseif b == 14 then
				return readNumber(8)
			elseif b == 15 then
				return readNumber(16)
			end
		end)
		
		local debX, debY, debColor
		
		local function lexHuffcode(dictionary, minlength)
			local bin = 2^minlength + readNumber(minlength)
			v = dictionary[bin]
			if v then return v end
			while not v do
				bin = bin*2 + readBit()
				v = dictionary[bin]
			end
			return v
		end
		
		local color, index, len, x, lastColor, z
		for y = 1, h do
			tImage[y] = {}
			x = 0
			lastColor = 16
			while x < w do
				if monoindex then
					index = indexcodes
				else
					index = lexHuffcode(indexcodes, minIClength)
				end
				if monolength then
					len = lengthcodes
				else
					len = lexHuffcode(lengthcodes, minLClength)
				end
				if index == 16 then
					color = 16
					z = 0
				elseif lastColor == 16 then
					color = alphabet[index]
					z = 2^color
				else
					color = alphabet[(iAlphabet[lastColor] + index) % 16]
					z = 2^color
				end
				
				for a = 1, len do
					tImage[y][#tImage[y]+1] = z
				end
				x = x + len
				
				lastColor = color
			end
		end
		return tImage, true
	else
		return nil, false, "unsupported version: "..(tostring(version) or "unknown")
	end
end

-- decodes a file in UCG format and returns an image
function readFile(path)
	if type(path) ~= "string" then error("Argument #1: string expected", 2) end
	if not fs.isDir(path) and fs.exists(path) then
		local s
		if doFastIO then 
			local r = fs.open(path, "r")
			s = r.readAll()
			r.close()
		else
			local r = fs.open(path, "rb")
			local b = r.read()
			s = {}
			while b do
				s[#s +1] = b
				b = r.read()
			end
			r.close()
		end
		return decode(s)
	else
		error("Can't read from "..path, 2)
	end
end
